# -*- coding: utf-8 -*-
"""cnnvgg16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GNEfPbRZQvIzXJH0VwFSTC4BLAyVAp8L
"""

!pip install roboflow
import os
import tensorflow as tf
from tensorflow.keras.applications import VGG16
from roboflow import Roboflow
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import numpy as np

# Roboflow API key ile bağlanma
rf = Roboflow(api_key="6ass88lllV0UMPfXoWaS")
project = rf.workspace("insectcnn").project("insect-6syav")

# Veri setinin indirilmesi
dataset = project.version(4).download("folder")

# Parametrelerin belirlenmesi
toplu_boyutu = 128
img_yukseklik = 300
img_genislik = 300

# Roboflow veri setlerinin yüklenmesi
# Eğitim veri setini yükleme
egitim_verisi = tf.keras.preprocessing.image_dataset_from_directory(
  "/content/insect-4/train",
  image_size=(img_yukseklik, img_genislik),
  batch_size=toplu_boyutu
)

# Doğrulama veri setini yükleme
dogrulama_verisi = tf.keras.preprocessing.image_dataset_from_directory(
  "/content/insect-4/valid",
  image_size=(img_yukseklik, img_genislik),
  batch_size=toplu_boyutu
)

# Test veri setini yükleme
test_verisi = tf.keras.preprocessing.image_dataset_from_directory(
  "/content/insect-4/test",
  image_size=(img_yukseklik, img_genislik),
  batch_size=toplu_boyutu
)

# Sınıf sayısını almak için kullanabilirsiniz
sinif_sayisi = len(egitim_verisi.class_names)

# Modelin hazırlanması - VGG16 modelini kullanacağız
vgg16_model = VGG16(weights='imagenet', include_top=False, input_shape=(img_yukseklik, img_genislik, 3))

model = tf.keras.models.Sequential()
model.add(vgg16_model)  # VGG16 modelini ekleyelim
model.add(tf.keras.layers.Flatten())  # Düzleştirme katmanı
model.add(tf.keras.layers.Dense(1024, activation='relu'))  # Yoğun bağlantılı katman
model.add(tf.keras.layers.Dropout(0.2))  # Dropout katmanı
model.add(tf.keras.layers.Dense(1024, activation='relu'))  # Bir başka yoğun bağlantılı katman
model.add(tf.keras.layers.Dropout(0.2))  # Dropout katmanı
model.add(tf.keras.layers.Dense(sinif_sayisi, activation='softmax'))  # Çıkış katmanı

# Modelin derlenmesi
model.compile(loss='categorical_crossentropy',
              optimizer=tf.keras.optimizers.Adam(learning_rate=1e-4),
              metrics=['accuracy'])

from google.colab import drive
drive.mount('/content/drive')

# Verinin one-hot kodlanması
def format_image(image, label):
    return image, tf.one_hot(label, sinif_sayisi)

egitim_ds = egitim_verisi.map(format_image)
dogrulama_ds = dogrulama_verisi.map(format_image)
test_ds = test_verisi.map(format_image)

# Optimizasyon: Veri setinde prefetching
AUTOTUNE = tf.data.AUTOTUNE
egitim_ds = egitim_ds.prefetch(buffer_size=AUTOTUNE)
dogrulama_ds = dogrulama_ds.prefetch(buffer_size=AUTOTUNE)
test_ds = test_ds.prefetch(buffer_size=AUTOTUNE)

# Callback'lerin ayarlanması
checkpoint_cb = tf.keras.callbacks.ModelCheckpoint("/content/gdrive/My Drive/vgg16_modelim.h5", save_best_only=True)
early_stopping_cb = tf.keras.callbacks.EarlyStopping(patience=10, restore_best_weights=True)

# Modelin Eğitilmesi
gecmis= model.fit(egitim_ds, validation_data=dogrulama_ds, epochs=20, callbacks=[checkpoint_cb, early_stopping_cb])

# Tahmin Grafiği
plt.plot(gecmis.history['accuracy'])
plt.plot(gecmis.history['val_accuracy'])
plt.title('Model Tahmini')
plt.xlabel('Çağ')
plt.ylabel('Keskinlik')
plt.legend(['Eğitim', 'Doğrulama'], loc='lower right')
plt.show()

# Kayıp Grafiği
plt.plot(gecmis.history['loss'])
plt.plot(gecmis.history['val_loss'])
plt.title('Model Kaybı')
plt.xlabel('Çağ')
plt.ylabel('Kayıp')
plt.legend(['Eğitim', 'Doğrulama'], loc='upper right')
plt.show()

# Tahminleri alalım ve onları tek bir diziye dönüştürelim
predictions = model.predict(test_ds)
predicted_classes = np.argmax(predictions, axis=1)

# Gerçek etiketleri alalım ve onları tek bir diziye dönüştürelim
real_classes = []
for images, labels in test_ds:
    real_classes.extend(np.argmax(labels.numpy(), axis=1))
real_classes = np.array(real_classes)

# Doğruluk matrisini hesaplayalım
cm = confusion_matrix(real_classes, predicted_classes)

# Matrisi görselleştirelim
cmd = ConfusionMatrixDisplay(cm, display_labels=egitim_verisi.class_names)
cmd.plot()

